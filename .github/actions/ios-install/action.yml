name: 'iOS App Install and Setup'
description: 'Download, install, and setup iOS app on simulator'
inputs:
  artifact_name:
    description: 'Name of the iOS app artifact to download'
    required: false
  download_url:
    description: 'Direct download URL for the iOS app bundle'
    required: false
  ios_version:
    description: 'iOS version for simulator'
    required: false
    default: '26.0'
  device_name:
    description: 'iOS simulator device name'
    required: false
    default: 'iPhone 16'
outputs:
  device_udid:
    description: 'UUID of the booted iOS simulator'
    value: ${{ steps.boot-simulator.outputs.device_udid }}
  bundle_id:
    description: 'Bundle ID of the installed app'
    value: ${{ steps.install-app.outputs.bundle_id }}
  app_path:
    description: 'Path to the installed app bundle'
    value: ${{ steps.verify-app.outputs.app_path }}

runs:
  using: 'composite'
  steps:
    - name: Download iOS app from artifact
      if: inputs.artifact_name != ''
      uses: actions/download-artifact@v4
      with:
        name: ${{ inputs.artifact_name }}
        path: ./downloaded-app

    - name: Download iOS app from URL
      if: inputs.download_url != ''
      shell: bash
      env:
        DOWNLOAD_URL: ${{ inputs.download_url }}
      run: |
        echo "ğŸ“¥ Downloading iOS app from URL..."
        echo "URL: $DOWNLOAD_URL"
        
        # Create download directory
        mkdir -p ./downloaded-app
        
        # Download the file
        curl -L -o ./downloaded-app/app_bundle.zip "$DOWNLOAD_URL"
        
        # Verify download
        if [ ! -f "./downloaded-app/app_bundle.zip" ]; then
          echo "âŒ ERROR: Download failed"
          exit 1
        fi
        
        # Check file size
        FILE_SIZE=$(stat -f%z "./downloaded-app/app_bundle.zip" 2>/dev/null || stat -c%s "./downloaded-app/app_bundle.zip")
        echo "âœ… Downloaded app bundle (${FILE_SIZE} bytes)"

    - name: Verify download method
      shell: bash
      env:
        ARTIFACT_NAME: ${{ inputs.artifact_name }}
        DOWNLOAD_URL: ${{ inputs.download_url }}
      run: |
        if [ -z "$ARTIFACT_NAME" ] && [ -z "$DOWNLOAD_URL" ]; then
          echo "âŒ ERROR: Either artifact_name or download_url must be provided"
          exit 1
        fi
        
        if [ -n "$ARTIFACT_NAME" ] && [ -n "$DOWNLOAD_URL" ]; then
          echo "âš ï¸ WARNING: Both artifact_name and download_url provided, using artifact_name"
        fi

    - name: Unzip app bundle
      shell: bash
      run: |
        echo "ğŸ“¦ Extracting app bundle..."
        
        # Find and extract the zip file
        if [ -f "./downloaded-app/app_bundle.zip" ]; then
          unzip "./downloaded-app/app_bundle.zip" -d ./downloaded-app/
          echo "âœ… App bundle extracted"
        else
          echo "âŒ ERROR: app_bundle.zip not found in ./downloaded-app"
          echo "Contents of ./downloaded-app:"
          ls -la ./downloaded-app/
          exit 1
        fi

    - name: Verify app bundle
      id: verify-app
      shell: bash
      run: |
        echo "ğŸ” Verifying .app bundle..."

        APP_PATH=$(find ./downloaded-app -name "*.app" -type d -maxdepth 2 | head -n 1)
        
        echo "Contents of ./downloaded-app:"
        ls -la ./downloaded-app/

        if [ -z "$APP_PATH" ]; then
          echo "âŒ ERROR: .app bundle not found"
          echo "Searching for .app files:"
          find ./downloaded-app -name "*.app" -type d
          exit 1
        fi

        if [ ! -f "$APP_PATH/Info.plist" ]; then
          echo "âŒ ERROR: Invalid .app bundle - missing Info.plist"
          exit 1
        fi

        # Extract bundle ID for verification
        BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$APP_PATH/Info.plist")
        echo "ğŸ“± Found valid app bundle: $(basename "$APP_PATH")"
        echo "ğŸ“‹ Bundle ID: $BUNDLE_ID"
        
        echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT
        echo "APP_PATH=$APP_PATH" >> $GITHUB_ENV
        echo "VERIFIED_BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV

    - name: List available iOS simulators
      shell: bash
      run: |
        echo "ğŸ“± Available iOS Simulators:"
        xcrun simctl list devices available

    - name: Find and boot iOS Simulator
      id: boot-simulator
      shell: bash
      env:
        INPUT_DEVICE_NAME: ${{ inputs.device_name }}
        INPUT_IOS_VERSION: ${{ inputs.ios_version }}
      run: |
        set -e
        DEVICE_NAME="$INPUT_DEVICE_NAME"
        PLATFORM_VERSION="$INPUT_IOS_VERSION"
        
        echo "ğŸ” Looking for: $DEVICE_NAME with iOS $PLATFORM_VERSION"
        
        # Use Python with JSON output for reliable parsing
        UDID=$(xcrun simctl list devices available -j | python3 -c "
          import json
          import sys

          data = json.load(sys.stdin)
          target_device = '$DEVICE_NAME'
          target_version = '$PLATFORM_VERSION'

          # Format the version for comparison (e.g., '26.0' -> 'iOS-26-0')
          formatted_version = 'iOS-' + target_version.replace(' ', '-').replace('.', '-')

          for runtime_key, devices in data.get('devices', {}).items():
              # Extract and format the runtime version from the key
              # Runtime keys look like: 'com.apple.CoreSimulator.SimRuntime.iOS-26-0'
              if formatted_version in runtime_key:
                  for device in devices:
                      if device.get('name') == target_device and device.get('isAvailable', False):
                          print(device['udid'])
                          sys.exit(0)

          # If we get here, device wasn't found
          sys.exit(1)
          " 2>/dev/null)
            
        if [ -z "$UDID" ]; then
          echo "âŒ ERROR: Could not find $DEVICE_NAME with iOS $PLATFORM_VERSION"
          echo ""
          echo "Available simulators:"
          xcrun simctl list devices available
          echo ""
          echo "Debugging - Runtime keys:"
          xcrun simctl list devices available -j | python3 -c "
            import json
            import sys
            data = json.load(sys.stdin)
            for key in data.get('devices', {}).keys():
                print(key)
          "
          exit 1
        fi
        
        echo "DEVICE_UDID=$UDID" >> $GITHUB_ENV
        echo "device_udid=$UDID" >> $GITHUB_OUTPUT
        echo "âœ… Found simulator: $DEVICE_NAME ($UDID)"
        
        # Boot the simulator with timeout protection
        echo "ğŸš€ Booting simulator..."
        xcrun simctl boot $UDID 2>/dev/null || echo "Simulator already booted or boot command completed"
        
        # Wait for boot to complete with timeout and fallback strategy
        echo "â³ Waiting for simulator to boot (timeout: 180 seconds)..."
        
        BOOT_TIMEOUT=180
        BOOT_SUCCESS=false
        
        for i in $(seq 1 $BOOT_TIMEOUT); do
          # Check if simulator is booted
          SIMULATOR_STATUS=$(xcrun simctl list devices | grep "$UDID" | head -1)
          if echo "$SIMULATOR_STATUS" | grep -q "(Booted)"; then
            BOOT_SUCCESS=true
            echo "âœ… Simulator booted successfully after ${i} seconds"
            break
          fi
          
          # Progress indicator every 10 seconds
          if [ $((i % 10)) -eq 0 ]; then
            echo "â³ Still waiting... (${i}/${BOOT_TIMEOUT} seconds)"
            echo "Current status: $SIMULATOR_STATUS"
          fi
          
          sleep 1
        done
        
        if [ "$BOOT_SUCCESS" = false ]; then
          echo "âŒ ERROR: Simulator failed to boot within $BOOT_TIMEOUT seconds"
          echo "Final status: $(xcrun simctl list devices | grep "$UDID" | head -1)"
          echo ""
          echo "ğŸ”§ Attempting recovery..."
          
          # Try to shutdown and reboot once
          echo "ğŸ”„ Shutting down simulator..."
          xcrun simctl shutdown $UDID || true
          sleep 5
          
          echo "ğŸš€ Attempting second boot..."
          xcrun simctl boot $UDID
          
          # Give it one more chance with shorter timeout
          echo "â³ Final boot attempt (60 seconds timeout)..."
          FINAL_TIMEOUT=60
          FINAL_SUCCESS=false
          
          for i in $(seq 1 $FINAL_TIMEOUT); do
            SIMULATOR_STATUS=$(xcrun simctl list devices | grep "$UDID" | head -1)
            if echo "$SIMULATOR_STATUS" | grep -q "(Booted)"; then
              FINAL_SUCCESS=true
              echo "âœ… Simulator recovered and booted after ${i} seconds"
              break
            fi
            sleep 1
          done
          
          if [ "$FINAL_SUCCESS" = false ]; then
            echo "âŒ FATAL: Simulator boot failed completely"
            echo "This might be a CI environment issue with iOS simulators"
            exit 1
          fi
        fi
        
        # Double-check simulator status and ensure it's ready for testing
        echo "ğŸ” Final verification that simulator is ready..."
        SIMULATOR_STATUS=$(xcrun simctl list devices | grep "$UDID" | head -1)
        echo "Simulator status: $SIMULATOR_STATUS"
        
        if echo "$SIMULATOR_STATUS" | grep -q "(Booted)"; then
          echo "âœ… Simulator is booted and ready for testing"
        else
          echo "âŒ ERROR: Simulator failed to reach booted state"
          echo "Current status: $SIMULATOR_STATUS"
          exit 1
        fi

    - name: Install app on simulator
      id: install-app
      shell: bash
      run: |
        echo "ğŸ“² Installing app on simulator..."
        echo "Device UDID: $DEVICE_UDID"
        echo "App path: $APP_PATH"
        
        # Install the app
        xcrun simctl install "$DEVICE_UDID" "$APP_PATH"
        
        # Extract and output bundle ID
        BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$APP_PATH/Info.plist")
        echo "BUNDLE_ID=${BUNDLE_ID}" >> $GITHUB_ENV
        echo "bundle_id=${BUNDLE_ID}" >> $GITHUB_OUTPUT
        
        echo "âœ… App installed successfully"
        echo "ğŸ“‹ Bundle ID: ${BUNDLE_ID}"

    - name: Launch and verify app
      shell: bash
      run: |
        echo "ğŸš€ Launching app..."
        xcrun simctl launch "$DEVICE_UDID" "$BUNDLE_ID"
        
        echo "â³ Waiting for app to initialize..."
        sleep 5
        
        # Verify app is installed and accessible for testing
        echo "ğŸ” Final app verification before testing..."
        if xcrun simctl listapps "$DEVICE_UDID" | grep -q "$BUNDLE_ID"; then
          echo "âœ… App $BUNDLE_ID is installed and available for Appium testing"
        else
          echo "âŒ ERROR: App not found after installation"
          echo "Installed apps:"
          xcrun simctl listapps "$DEVICE_UDID"
          exit 1
        fi
        
        echo "ğŸ¯ App launched successfully and ready for testing"