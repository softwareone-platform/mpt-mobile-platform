name: 'Android App Install and Setup (Windows)'
description: 'Download, install, and setup Android app on emulator (Windows)'
inputs:
  artifact_name:
    description: 'Name of the Android APK artifact to download'
    required: false
  download_url:
    description: 'Direct download URL for the APK'
    required: false
  api_level:
    description: 'Android API level for emulator'
    required: false
    default: '34'
  device_profile:
    description: 'Android emulator device profile'
    required: false
    default: 'pixel_6'
  arch:
    description: 'System image architecture'
    required: false
    default: 'x86_64'
outputs:
  device_serial:
    description: 'ADB device serial (e.g., emulator-5554)'
    value: ${{ steps.boot-emulator.outputs.device_serial }}
  package_name:
    description: 'Android package name'
    value: ${{ steps.verify-apk.outputs.package_name }}
  apk_path:
    description: 'Path to the APK file'
    value: ${{ steps.verify-apk.outputs.apk_path }}
  avd_name:
    description: 'Name of the Android Virtual Device'
    value: ${{ steps.create-avd.outputs.avd_name }}

runs:
  using: 'composite'
  steps:
    - name: Verify Required Inputs
      shell: pwsh
      run: |
        Write-Host "üîç Verifying required inputs..."
        
        if (-not "${{ inputs.artifact_name }}" -and -not "${{ inputs.download_url }}") {
          Write-Host "‚ùå ERROR: Either artifact_name or download_url must be provided"
          exit 1
        }
        
        if ("${{ inputs.artifact_name }}" -and "${{ inputs.download_url }}") {
          Write-Host "‚ö†Ô∏è WARNING: Both artifact_name and download_url provided, using artifact_name"
        }
        
        Write-Host "‚úÖ API Level: ${{ inputs.api_level }}"
        Write-Host "‚úÖ Device Profile: ${{ inputs.device_profile }}"
        Write-Host "‚úÖ Architecture: ${{ inputs.arch }}"
        Write-Host "üéâ Input verification complete!"

    - name: Download APK from artifact
      if: inputs.artifact_name != ''
      uses: actions/download-artifact@v4
      with:
        name: ${{ inputs.artifact_name }}
        path: ./downloaded-apk

    - name: Download APK from URL
      if: inputs.download_url != '' && inputs.artifact_name == ''
      shell: pwsh
      run: |
        Write-Host "üì• Downloading APK from URL..."
        Write-Host "URL: ${{ inputs.download_url }}"
        
        New-Item -ItemType Directory -Force -Path ./downloaded-apk | Out-Null
        Invoke-WebRequest -Uri "${{ inputs.download_url }}" -OutFile "./downloaded-apk/app.apk"
        
        if (-not (Test-Path "./downloaded-apk/app.apk")) {
          Write-Host "‚ùå ERROR: Download failed"
          exit 1
        }
        
        $FileSize = (Get-Item "./downloaded-apk/app.apk").Length
        Write-Host "‚úÖ Downloaded APK ($FileSize bytes)"

    - name: Verify APK artifact
      id: verify-apk
      shell: pwsh
      run: |
        Write-Host "üîç Verifying APK artifact..."
        
        # Find the APK file
        $ApkFile = Get-ChildItem -Path "./downloaded-apk" -Filter "*.apk" -Recurse | Select-Object -First 1
        
        Write-Host "Contents of ./downloaded-apk:"
        Get-ChildItem -Path "./downloaded-apk" -Recurse
        
        if (-not $ApkFile) {
          Write-Host "‚ùå ERROR: APK file not found"
          exit 1
        }
        
        $ApkPath = $ApkFile.FullName
        $Size = $ApkFile.Length
        Write-Host "üì¶ APK size: $Size bytes"
        
        if ($Size -lt 1000000) {
          Write-Host "‚ùå ERROR: APK suspiciously small: $Size bytes"
          exit 1
        }
        
        # Try to extract package name using aapt
        $AaptPath = Get-ChildItem -Path "$env:ANDROID_HOME\build-tools" -Filter "aapt.exe" -Recurse | 
                    Sort-Object { $_.Directory.Name } | 
                    Select-Object -Last 1
        
        $PackageName = "com.softwareone.marketplaceMobile"
        
        if ($AaptPath) {
          try {
            $PackageInfo = & $AaptPath.FullName dump badging $ApkPath 2>$null | Select-Object -First 5
            $Match = $PackageInfo | Select-String -Pattern "package: name='([^']+)'"
            if ($Match) {
              $PackageName = $Match.Matches[0].Groups[1].Value
              Write-Host "üì¶ Extracted package name: $PackageName"
            }
          } catch {
            Write-Host "‚ö†Ô∏è Could not extract package name with aapt"
          }
        }
        
        # Convert to forward slashes for cross-platform compatibility
        $ApkPathNormalized = $ApkPath.Replace("\", "/")
        
        "apk_path=$ApkPathNormalized" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        "package_name=$PackageName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        
        # Also set environment variables for later steps
        "APK_PATH=$ApkPathNormalized" | Out-File -FilePath $env:GITHUB_ENV -Append
        "PACKAGE_NAME=$PackageName" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        Write-Host "‚úÖ APK verified: $ApkPath"
        Write-Host "üì¶ Package: $PackageName"

    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Setup Android SDK
      shell: pwsh
      run: |
        Write-Host "üîß Setting up Android SDK..."
        
        # Verify ANDROID_HOME is set
        if (-not $env:ANDROID_HOME) {
          Write-Host "‚ùå ERROR: ANDROID_HOME not set"
          exit 1
        }
        
        Write-Host "ANDROID_HOME: $env:ANDROID_HOME"
        
        # Add Android SDK tools to PATH for subsequent steps
        $PlatformTools = Join-Path $env:ANDROID_HOME "platform-tools"
        $Emulator = Join-Path $env:ANDROID_HOME "emulator"
        $CmdlineTools = Join-Path $env:ANDROID_HOME "cmdline-tools\latest\bin"
        
        # Add to GITHUB_PATH for subsequent steps
        $PlatformTools | Out-File -FilePath $env:GITHUB_PATH -Append
        $Emulator | Out-File -FilePath $env:GITHUB_PATH -Append
        $CmdlineTools | Out-File -FilePath $env:GITHUB_PATH -Append
        
        Write-Host "üìÅ Added to PATH: $PlatformTools"
        Write-Host "üìÅ Added to PATH: $Emulator"
        Write-Host "üìÅ Added to PATH: $CmdlineTools"
        
        # Set ANDROID_SDK_HOME to control where .android folder is created
        # This ensures AVDs are created in a consistent location
        $AndroidSdkHome = $env:USERPROFILE
        $AndroidAvdHome = Join-Path $env:USERPROFILE ".android\avd"
        
        # Create the AVD directory if it doesn't exist
        if (-not (Test-Path $AndroidAvdHome)) {
          New-Item -ItemType Directory -Force -Path $AndroidAvdHome | Out-Null
        }
        
        "ANDROID_SDK_HOME=$AndroidSdkHome" | Out-File -FilePath $env:GITHUB_ENV -Append
        "ANDROID_AVD_HOME=$AndroidAvdHome" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        Write-Host "üìÅ SDK Home: $AndroidSdkHome"
        Write-Host "üìÅ AVD Home: $AndroidAvdHome"
        
        # Accept licenses
        $SdkManager = Join-Path $env:ANDROID_HOME "cmdline-tools\latest\bin\sdkmanager.bat"
        
        if (-not (Test-Path $SdkManager)) {
          # Try alternative path
          $SdkManager = Get-ChildItem -Path "$env:ANDROID_HOME" -Filter "sdkmanager.bat" -Recurse | Select-Object -First 1
          if ($SdkManager) {
            $SdkManager = $SdkManager.FullName
          }
        }
        
        if (Test-Path $SdkManager) {
          Write-Host "Using sdkmanager: $SdkManager"
          # Accept all licenses including the new android-googlexr-license
          echo "y`ny`ny`ny`ny`ny`ny`ny" | & $SdkManager --licenses 2>$null
        } else {
          Write-Host "‚ö†Ô∏è sdkmanager not found, assuming licenses are accepted"
        }
        
        Write-Host "‚úÖ Android SDK ready"

    - name: Install SDK Components
      shell: pwsh
      run: |
        Write-Host "üì¶ Installing SDK components for API ${{ inputs.api_level }}..."
        
        $SdkManager = Join-Path $env:ANDROID_HOME "cmdline-tools\latest\bin\sdkmanager.bat"
        
        if (-not (Test-Path $SdkManager)) {
          $SdkManagerFile = Get-ChildItem -Path "$env:ANDROID_HOME" -Filter "sdkmanager.bat" -Recurse | Select-Object -First 1
          if ($SdkManagerFile) {
            $SdkManager = $SdkManagerFile.FullName
          } else {
            Write-Host "‚ùå ERROR: sdkmanager not found"
            exit 1
          }
        }
        
        # Install required components
        & $SdkManager "system-images;android-${{ inputs.api_level }};google_apis;${{ inputs.arch }}" --verbose
        & $SdkManager "emulator" --verbose
        & $SdkManager "platform-tools" --verbose
        & $SdkManager "platforms;android-${{ inputs.api_level }}" --verbose
        
        Write-Host "‚úÖ SDK components installed"

    - name: Enable Windows Hypervisor Platform
      shell: pwsh
      run: |
        Write-Host "üîß Checking hardware acceleration..."
        
        # Check if WHPX is available
        $WhpxCheck = & "$env:ANDROID_HOME\emulator\emulator.exe" -accel-check 2>&1
        Write-Host "Acceleration check: $WhpxCheck"
        
        # WHPX should be available on GitHub Windows runners
        if ($WhpxCheck -match "WHPX" -or $WhpxCheck -match "Hyper-V") {
          Write-Host "‚úÖ Hardware acceleration available"
        } else {
          Write-Host "‚ö†Ô∏è Hardware acceleration may not be available, emulator might be slow"
        }

    - name: Create Android Virtual Device
      id: create-avd
      shell: pwsh
      run: |
        Write-Host "üì± Creating Android Virtual Device..."
        
        $AvdName = "test_avd_${{ inputs.api_level }}"
        $AvdManager = Join-Path $env:ANDROID_HOME "cmdline-tools\latest\bin\avdmanager.bat"
        
        if (-not (Test-Path $AvdManager)) {
          $AvdManagerFile = Get-ChildItem -Path "$env:ANDROID_HOME" -Filter "avdmanager.bat" -Recurse | Select-Object -First 1
          if ($AvdManagerFile) {
            $AvdManager = $AvdManagerFile.FullName
          } else {
            Write-Host "‚ùå ERROR: avdmanager not found"
            exit 1
          }
        }
        
        # Set ANDROID_SDK_HOME to ensure AVD is created in the right place
        $env:ANDROID_SDK_HOME = $env:USERPROFILE
        Write-Host "üìÅ Using ANDROID_SDK_HOME: $env:ANDROID_SDK_HOME"
        
        # Delete existing AVD if present
        & $AvdManager delete avd --name $AvdName 2>$null
        
        # Create AVD
        echo "no" | & $AvdManager create avd `
          --name $AvdName `
          --package "system-images;android-${{ inputs.api_level }};google_apis;${{ inputs.arch }}" `
          --device "${{ inputs.device_profile }}" `
          --force
        
        # Verify AVD was created
        $ExpectedAvdPath = Join-Path $env:USERPROFILE ".android\avd\$AvdName.avd"
        if (Test-Path $ExpectedAvdPath) {
          Write-Host "‚úÖ AVD directory found at: $ExpectedAvdPath"
          
          # Optimize AVD config for faster boot in CI
          $ConfigPath = Join-Path $ExpectedAvdPath "config.ini"
          if (Test-Path $ConfigPath) {
            Write-Host "üîß Optimizing AVD configuration for CI..."
            $Config = Get-Content $ConfigPath
            
            # Override settings for faster/lighter emulator
            $Optimizations = @{
              "hw.lcd.density" = "320"          # Lower density (was 420 for pixel_6)
              "hw.lcd.width" = "720"            # Lower resolution
              "hw.lcd.height" = "1280"          # Lower resolution  
              "hw.ramSize" = "2048"             # Match emulator memory setting
              "hw.keyboard" = "yes"             # Hardware keyboard
              "hw.gpu.enabled" = "no"           # Disable GPU in config (emulator args control this)
              "hw.gpu.mode" = "off"             # GPU mode off
              "hw.camera.back" = "none"         # No back camera
              "hw.camera.front" = "none"        # No front camera
              "hw.gps" = "no"                   # No GPS
              "hw.sensors.proximity" = "no"    # No proximity sensor
              "hw.sensors.magnetic_field" = "no" # No magnetic sensor
              "hw.sensors.orientation" = "no"   # No orientation sensor
              "hw.sensors.temperature" = "no"   # No temperature sensor
              "hw.sensors.light" = "no"         # No light sensor
              "hw.sensors.pressure" = "no"      # No pressure sensor
              "hw.sensors.humidity" = "no"      # No humidity sensor
              "disk.dataPartition.size" = "2G"  # Smaller data partition
              "fastboot.chosenSnapshotFile" = "" # No snapshot
              "fastboot.forceChosenSnapshotBoot" = "no"
              "fastboot.forceFastBoot" = "no"
            }
            
            foreach ($Key in $Optimizations.Keys) {
              $Value = $Optimizations[$Key]
              if ($Config -match "^$Key\s*=") {
                $Config = $Config -replace "^$Key\s*=.*", "$Key=$Value"
              } else {
                $Config += "`n$Key=$Value"
              }
            }
            
            $Config | Set-Content $ConfigPath
            Write-Host "‚úÖ AVD config optimized"
          }
        } else {
          Write-Host "‚ö†Ô∏è AVD not at expected location, searching..."
          Get-ChildItem -Path $env:USERPROFILE -Filter "$AvdName.avd" -Recurse -Directory -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found AVD at: $($_.FullName)"
          }
        }
        
        "avd_name=$AvdName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        "AVD_NAME=$AvdName" | Out-File -FilePath $env:GITHUB_ENV -Append
        Write-Host "‚úÖ AVD created: $AvdName"

    - name: Verify AVD Created
      shell: pwsh
      run: |
        Write-Host "üîç Verifying AVD creation..."
        
        $AvdManager = Join-Path $env:ANDROID_HOME "cmdline-tools\latest\bin\avdmanager.bat"
        
        if (-not (Test-Path $AvdManager)) {
          $AvdManagerFile = Get-ChildItem -Path "$env:ANDROID_HOME" -Filter "avdmanager.bat" -Recurse | Select-Object -First 1
          if ($AvdManagerFile) {
            $AvdManager = $AvdManagerFile.FullName
          }
        }
        
        $AvdName = "${{ steps.create-avd.outputs.avd_name }}"
        
        # Set ANDROID_SDK_HOME for avdmanager
        $env:ANDROID_SDK_HOME = $env:USERPROFILE
        
        # Get AVD list as an array of lines
        $AvdListOutput = & $AvdManager list avd 2>&1
        
        # Convert to string for matching (join with newlines)
        $AvdListString = $AvdListOutput -join "`n"
        
        Write-Host "üìã Available AVDs:"
        Write-Host $AvdListString
        
        # Check if AVD name appears in the list (more robust check)
        $AvdFound = $false
        foreach ($line in $AvdListOutput) {
          if ($line -match "Name:\s*$AvdName" -or $line -match "$AvdName\.avd") {
            $AvdFound = $true
            break
          }
        }
        
        # Also check if the AVD directory exists as a fallback
        $AvdPath = Join-Path $env:USERPROFILE ".android\avd\$AvdName.avd"
        if (Test-Path $AvdPath) {
          Write-Host "üìÅ AVD directory exists at: $AvdPath"
          $AvdFound = $true
        }
        
        if (-not $AvdFound) {
          Write-Host "‚ùå ERROR: AVD not found: $AvdName"
          Write-Host "Searching for AVD files..."
          Get-ChildItem -Path $env:USERPROFILE -Filter "*.avd" -Recurse -Directory -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found: $($_.FullName)"
          }
          exit 1
        }
        
        Write-Host "‚úÖ AVD verified: $AvdName"

    - name: Boot Android Emulator
      id: boot-emulator
      shell: pwsh
      run: |
        Write-Host "üöÄ Starting Android Emulator..."
        
        $AvdName = "${{ steps.create-avd.outputs.avd_name }}"
        $EmulatorPath = Join-Path $env:ANDROID_HOME "emulator\emulator.exe"
        $AdbPath = Join-Path $env:ANDROID_HOME "platform-tools\adb.exe"
        
        # Set ANDROID_SDK_HOME to ensure emulator finds the AVD
        $env:ANDROID_SDK_HOME = $env:USERPROFILE
        $env:ANDROID_AVD_HOME = Join-Path $env:USERPROFILE ".android\avd"
        
        Write-Host "üìÅ ANDROID_SDK_HOME: $env:ANDROID_SDK_HOME"
        Write-Host "üìÅ ANDROID_AVD_HOME: $env:ANDROID_AVD_HOME"
        
        # Debug: Check AVD files exist
        $AvdIniPath = Join-Path $env:USERPROFILE ".android\avd\$AvdName.ini"
        $AvdDirPath = Join-Path $env:USERPROFILE ".android\avd\$AvdName.avd"
        Write-Host "üîç Checking AVD files:"
        Write-Host "  INI file: $AvdIniPath - Exists: $(Test-Path $AvdIniPath)"
        Write-Host "  AVD dir:  $AvdDirPath - Exists: $(Test-Path $AvdDirPath)"
        
        # Helper function to clean up lock files safely
        function Remove-EmulatorLocks {
          param([string]$AvdPath)
          if (-not $AvdPath -or -not (Test-Path $AvdPath)) {
            Write-Host "  ‚ö†Ô∏è AVD path not valid for lock cleanup: $AvdPath"
            return
          }
          $LockPatterns = @("hardware-qemu.ini.lock", "multiinstance.lock", ".lock")
          foreach ($Pattern in $LockPatterns) {
            $LockPath = Join-Path $AvdPath $Pattern
            if ($LockPath -and (Test-Path $LockPath -ErrorAction SilentlyContinue)) {
              try {
                Write-Host "  Removing: $LockPath"
                Remove-Item -Path $LockPath -Force -ErrorAction Stop
              } catch {
                Write-Host "  ‚ö†Ô∏è Could not remove $LockPath : $_"
              }
            }
          }
        }
        
        # Clean up any stale lock files from previous runs (prevents "Running multiple emulators" error)
        Write-Host "üßπ Cleaning up stale emulator lock files..."
        Remove-EmulatorLocks -AvdPath $AvdDirPath
        
        # Kill any existing emulator processes
        Write-Host "üßπ Killing any existing emulator processes..."
        Get-Process -Name "qemu-system-x86_64*" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
        Get-Process -Name "emulator*" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
        Start-Sleep -Seconds 2
        
        # Start ADB server first
        Write-Host "Starting ADB server..."
        & $AdbPath kill-server 2>$null
        Start-Sleep -Seconds 1
        & $AdbPath start-server
        
        # Try different GPU and acceleration configurations
        # Windows Server 2025 + emulator 36.x has known issues with gfxstream
        $RetryCount = 0
        # Configuration: [GPU mode, Acceleration mode, Extra args]
        $Configurations = @(
          @{ Gpu = "swiftshader_indirect"; Accel = "auto"; Extra = @() },
          @{ Gpu = "off"; Accel = "auto"; Extra = @() },
          @{ Gpu = "swiftshader_indirect"; Accel = "off"; Extra = @("-no-accel") },
          @{ Gpu = "off"; Accel = "off"; Extra = @("-no-accel") }
        )
        $AdbReady = $false
        $DeviceSerial = $null
        
        foreach ($Config in $Configurations) {
          if ($AdbReady) { break }
          
          $RetryCount++
          $GpuMode = $Config.Gpu
          $AccelMode = $Config.Accel
          Write-Host "üîÑ Attempt $RetryCount/$($Configurations.Count) - GPU: $GpuMode, Accel: $AccelMode"
          
          # Clean up lock files between attempts using safe helper
          Remove-EmulatorLocks -AvdPath $AvdDirPath
          
          # Build emulator arguments optimized for CI (fast boot, minimal resources)
          $CurrentArgs = @(
            "-avd", $AvdName,
            "-no-window",
            "-no-audio",
            "-no-boot-anim",
            "-gpu", $GpuMode,
            "-no-snapshot-load",
            "-no-snapshot-save",
            "-wipe-data",
            "-memory", "2048",
            "-cores", "2",
            "-no-metrics",
            # Additional performance optimizations
            "-no-sim",              # No SIM card - faster boot
            "-no-cache",            # No cache partition
            "-skip-adb-auth",       # Skip ADB authorization
            "-no-passive-gps",      # Disable GPS
            "-netdelay", "none",    # No network delay
            "-netspeed", "full",    # Full network speed
            "-screen", "no-touch",  # Disable touch screen (we use ADB)
            "-partition-size", "2048"  # Smaller partition = faster wipe
          )
          
          # Add extra args from configuration
          if ($Config.Extra.Count -gt 0) {
            $CurrentArgs += $Config.Extra
          }
          
          Write-Host "Starting emulator with args: $($CurrentArgs -join ' ')"
          
          $EmulatorProcess = Start-Process -FilePath $EmulatorPath `
            -ArgumentList $CurrentArgs `
            -PassThru `
            -NoNewWindow `
            -RedirectStandardOutput "emulator_stdout_$RetryCount.log" `
            -RedirectStandardError "emulator_stderr_$RetryCount.log"
          
          $EmulatorProcess.Id | Out-File -FilePath "emulator.pid"
          Write-Host "Emulator PID: $($EmulatorProcess.Id)"
          
          # Wait for device to appear in ADB (longer timeout for last attempt)
          $AdbTimeout = if ($RetryCount -eq $Configurations.Count) { 180 } else { 90 }
          
          for ($i = 1; $i -le $AdbTimeout; $i++) {
            $Devices = & $AdbPath devices 2>&1
            if ($Devices -match "emulator-") {
              Write-Host "‚úÖ Emulator appeared in ADB after $i seconds (GPU: $GpuMode, Accel: $AccelMode)"
              $AdbReady = $true
              $DeviceSerial = ($Devices | Select-String "emulator-" | Select-Object -First 1).ToString().Split()[0]
              break
            }
            
            if ($i % 15 -eq 0) {
              Write-Host "‚è≥ Waiting for ADB... ($i/$AdbTimeout s)"
              
              # Check if emulator process crashed
              if ($EmulatorProcess.HasExited) {
                Write-Host "‚ö†Ô∏è Emulator exited with code: $($EmulatorProcess.ExitCode)"
                Write-Host "Emulator stderr:"
                if (Test-Path "emulator_stderr_$RetryCount.log") { 
                  Get-Content "emulator_stderr_$RetryCount.log" -Tail 50 
                }
                break
              }
            }
            
            Start-Sleep -Seconds 1
          }
          
          # Kill emulator if it didn't work and we're retrying
          if (-not $AdbReady) {
            Write-Host "‚ö†Ô∏è Attempt $RetryCount failed, cleaning up..."
            try {
              if ($EmulatorProcess -and -not $EmulatorProcess.HasExited) {
                Stop-Process -Id $EmulatorProcess.Id -Force -ErrorAction SilentlyContinue
              }
            } catch {
              Write-Host "  ‚ö†Ô∏è Error stopping emulator process: $_"
            }
            # Also kill any orphaned processes
            Get-Process -Name "qemu-system-x86_64*" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
            Get-Process -Name "emulator*" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
            # Restart ADB to clear any stale state
            & $AdbPath kill-server 2>$null
            Start-Sleep -Seconds 2
            & $AdbPath start-server
            Start-Sleep -Seconds 1
          }
        }
        
        if (-not $AdbReady) {
          Write-Host "‚ùå ERROR: Emulator failed to start after $($Configurations.Count) attempts"
          & $AdbPath devices
          
          foreach ($n in 1..$RetryCount) {
            Write-Host "--- Attempt $n logs ---"
            Write-Host "Emulator stdout:"
            if (Test-Path "emulator_stdout_$n.log") { Get-Content "emulator_stdout_$n.log" -Tail 50 }
            Write-Host "Emulator stderr:"
            if (Test-Path "emulator_stderr_$n.log") { Get-Content "emulator_stderr_$n.log" -Tail 50 }
          }
          
          exit 1
        }
        
        "device_serial=$DeviceSerial" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        "DEVICE_SERIAL=$DeviceSerial" | Out-File -FilePath $env:GITHUB_ENV -Append
        Write-Host "‚úÖ Device serial: $DeviceSerial"

    - name: Verify Emulator Boot Complete
      shell: pwsh
      run: |
        Write-Host "‚è≥ Waiting for emulator boot to complete..."
        
        $DeviceSerial = "${{ steps.boot-emulator.outputs.device_serial }}"
        $AdbPath = Join-Path $env:ANDROID_HOME "platform-tools\adb.exe"
        
        $BootTimeout = 180
        $BootSuccess = $false
        
        for ($i = 1; $i -le $BootTimeout; $i++) {
          # Check 1: sys.boot_completed
          $BootCompleted = (& $AdbPath -s $DeviceSerial shell getprop sys.boot_completed 2>$null).Trim()
          
          # Check 2: Boot animation stopped
          $BootAnim = (& $AdbPath -s $DeviceSerial shell getprop init.svc.bootanim 2>$null).Trim()
          
          if ($BootCompleted -eq "1" -and $BootAnim -eq "stopped") {
            Write-Host "‚úÖ Boot completed after $i seconds"
            Write-Host "   sys.boot_completed=$BootCompleted"
            Write-Host "   init.svc.bootanim=$BootAnim"
            $BootSuccess = $true
            break
          }
          
          if ($i % 15 -eq 0) {
            Write-Host "‚è≥ Boot progress: boot_completed=$BootCompleted, bootanim=$BootAnim ($i/$BootTimeout s)"
          }
          
          Start-Sleep -Seconds 1
        }
        
        if (-not $BootSuccess) {
          Write-Host "‚ùå ERROR: Emulator failed to boot within $BootTimeout seconds"
          Write-Host "Final state: boot_completed=$BootCompleted, bootanim=$BootAnim"
          
          # Attempt recovery
          Write-Host "üîÑ Attempting recovery..."
          & $AdbPath -s $DeviceSerial reboot
          
          $RecoveryTimeout = 120
          for ($i = 1; $i -le $RecoveryTimeout; $i++) {
            $BootCompleted = (& $AdbPath -s $DeviceSerial shell getprop sys.boot_completed 2>$null).Trim()
            $BootAnim = (& $AdbPath -s $DeviceSerial shell getprop init.svc.bootanim 2>$null).Trim()
            
            if ($BootCompleted -eq "1" -and $BootAnim -eq "stopped") {
              Write-Host "‚úÖ Recovery successful after $i seconds"
              $BootSuccess = $true
              break
            }
            
            Start-Sleep -Seconds 1
          }
          
          if (-not $BootSuccess) {
            Write-Host "‚ùå FATAL: Emulator boot recovery failed"
            exit 1
          }
        }
        
        # Additional stability wait
        Write-Host "‚è≥ Waiting for system stability..."
        Start-Sleep -Seconds 10
        
        # Verify package manager is responsive
        Write-Host "üîç Verifying package manager..."
        $PmTimeout = 30
        $PmReady = $false
        
        for ($i = 1; $i -le $PmTimeout; $i++) {
          $PmResult = & $AdbPath -s $DeviceSerial shell pm list packages 2>&1
          if ($LASTEXITCODE -eq 0 -and $PmResult) {
            Write-Host "‚úÖ Package manager responsive"
            $PmReady = $true
            break
          }
          Start-Sleep -Seconds 1
        }
        
        if (-not $PmReady) {
          Write-Host "‚ùå ERROR: Package manager not responsive"
          exit 1
        }
        
        # Unlock screen
        Write-Host "üîì Unlocking screen..."
        & $AdbPath -s $DeviceSerial shell input keyevent 82 2>$null
        
        Write-Host "‚úÖ Emulator fully operational"

    - name: Install APK on Emulator
      shell: pwsh
      run: |
        Write-Host "üì≤ Installing APK on emulator..."
        
        $DeviceSerial = "${{ steps.boot-emulator.outputs.device_serial }}"
        $ApkPath = "${{ steps.verify-apk.outputs.apk_path }}"
        $AdbPath = Join-Path $env:ANDROID_HOME "platform-tools\adb.exe"
        
        Write-Host "Device: $DeviceSerial"
        Write-Host "APK: $ApkPath"
        
        # Install with replace flag
        $InstallOutput = & $AdbPath -s $DeviceSerial install -r $ApkPath 2>&1
        $InstallResult = $LASTEXITCODE
        
        Write-Host $InstallOutput
        
        if ($InstallResult -ne 0) {
          Write-Host "‚ùå APK installation failed"
          
          # Try uninstalling first if it exists
          $PackageName = "${{ steps.verify-apk.outputs.package_name }}"
          Write-Host "üîÑ Attempting to uninstall existing package..."
          & $AdbPath -s $DeviceSerial uninstall $PackageName 2>$null
          
          Write-Host "üîÑ Retrying installation..."
          $RetryOutput = & $AdbPath -s $DeviceSerial install $ApkPath 2>&1
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "‚ùå FATAL: APK installation failed after retry"
            Write-Host $RetryOutput
            exit 1
          }
        }
        
        Write-Host "‚úÖ APK installed"

    - name: Verify APK Installation
      shell: pwsh
      run: |
        Write-Host "üîç Verifying APK installation..."
        
        $DeviceSerial = "${{ steps.boot-emulator.outputs.device_serial }}"
        $PackageName = "${{ steps.verify-apk.outputs.package_name }}"
        $AdbPath = Join-Path $env:ANDROID_HOME "platform-tools\adb.exe"
        
        # Check if package is installed
        $InstalledPackages = & $AdbPath -s $DeviceSerial shell pm list packages 2>&1
        
        if ($InstalledPackages -notmatch $PackageName) {
          Write-Host "‚ùå ERROR: Package not found after installation: $PackageName"
          Write-Host "Installed packages containing 'softwareone':"
          $InstalledPackages | Select-String -Pattern "softwareone"
          exit 1
        }
        
        Write-Host "‚úÖ Package verified: $PackageName"

    - name: Launch Application
      shell: pwsh
      run: |
        Write-Host "üöÄ Launching application..."
        
        $DeviceSerial = "${{ steps.boot-emulator.outputs.device_serial }}"
        $PackageName = "${{ steps.verify-apk.outputs.package_name }}"
        $AdbPath = Join-Path $env:ANDROID_HOME "platform-tools\adb.exe"
        
        # Try to get main activity from package info
        $PackageDump = & $AdbPath -s $DeviceSerial shell pm dump $PackageName 2>$null
        $MainActivityMatch = $PackageDump | Select-String -Pattern "android.intent.action.MAIN" -Context 0,1
        
        $MainActivity = "$PackageName/.MainActivity"
        
        if ($MainActivityMatch) {
          $ActivityLine = $MainActivityMatch.Context.PostContext | Select-String -Pattern "$PackageName/[a-zA-Z0-9._]+"
          if ($ActivityLine) {
            $MainActivity = $ActivityLine.Matches[0].Value
          }
        }
        
        Write-Host "Starting activity: $MainActivity"
        
        $StartResult = & $AdbPath -s $DeviceSerial shell am start -n $MainActivity 2>&1
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "‚ö†Ô∏è am start failed, trying monkey..."
          & $AdbPath -s $DeviceSerial shell monkey -p $PackageName -c android.intent.category.LAUNCHER 1
        }
        
        Start-Sleep -Seconds 5
        
        # Verify app is running
        $Activities = & $AdbPath -s $DeviceSerial shell dumpsys activity activities 2>$null
        $ResumedActivity = $Activities | Select-String -Pattern "mResumedActivity|topResumedActivity" | Select-Object -First 1
        
        if ($ResumedActivity -match $PackageName) {
          Write-Host "‚úÖ App launched and in foreground"
        } else {
          Write-Host "‚ö†Ô∏è App may not be in foreground: $ResumedActivity"
          Write-Host "Continuing anyway - Appium will handle app launch"
        }

    - name: Installation Summary
      shell: pwsh
      run: |
        @"
        ## üì± Android Install Summary (Windows)
        
        **Device Serial:** ${{ steps.boot-emulator.outputs.device_serial }}
        **AVD Name:** ${{ steps.create-avd.outputs.avd_name }}
        **API Level:** ${{ inputs.api_level }}
        **Device Profile:** ${{ inputs.device_profile }}
        **Package Name:** ${{ steps.verify-apk.outputs.package_name }}
        **Runner:** Windows
        
        ‚úÖ **Status:** App installed and ready for testing
        "@ | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
