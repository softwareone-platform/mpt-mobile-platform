name: iOS App Install and Setup

permissions:
  contents: read

on:
  workflow_call:
    inputs:
      artifact_name:
        description: 'Name of the iOS app artifact to download'
        required: false
        type: string
      download_url:
        description: 'Direct download URL for the iOS app bundle (alternative to artifact_name)'
        required: false
        type: string
      ios_version:
        description: 'iOS version for simulator'
        required: false
        type: string
        default: '26.0'
      device_name:
        description: 'iOS simulator device name'
        required: false
        type: string
        default: 'iPhone 16'

    outputs:
      device_udid:
        description: 'UUID of the booted iOS simulator'
        value: ${{ jobs.verify-and-install-ios.outputs.device_udid }}
      bundle_id:
        description: 'Bundle ID of the installed app'
        value: ${{ jobs.verify-and-install-ios.outputs.bundle_id }}

jobs:
  verify-and-install-ios:
    name: Install iOS App and Setup Simulator
    runs-on: macos-latest
    timeout-minutes: 30

    env:
      PLATFORM_VERSION: ${{ inputs.ios_version || '26.0' }}
      DEVICE_NAME: ${{ inputs.device_name || 'iPhone 16' }}

    outputs:
      device_udid: ${{ steps.boot-simulator.outputs.device_udid }}
      bundle_id: ${{ steps.install-app.outputs.bundle_id }}

    steps:
      - name: Download iOS app from artifact
        if: inputs.artifact_name != ''
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: ./downloaded-app

      - name: Download iOS app from URL
        if: inputs.download_url != ''
        run: |
          echo "üì• Downloading iOS app from URL..."
          echo "URL: ${{ inputs.download_url }}"
          
          # Create download directory
          mkdir -p ./downloaded-app
          
          # Download the file
          curl -L -o ./downloaded-app/app_bundle.zip "${{ inputs.download_url }}"
          
          # Verify download
          if [ ! -f "./downloaded-app/app_bundle.zip" ]; then
            echo "‚ùå ERROR: Download failed"
            exit 1
          fi
          
          # Check file size
          FILE_SIZE=$(stat -f%z "./downloaded-app/app_bundle.zip" 2>/dev/null || stat -c%s "./downloaded-app/app_bundle.zip")
          echo "‚úÖ Downloaded app bundle (${FILE_SIZE} bytes)"
          
          # Validate it's a valid ZIP file
          echo "üîç Validating ZIP file..."
          if ! unzip -t "./downloaded-app/app_bundle.zip" >/dev/null 2>&1; then
            echo "‚ùå ERROR: Downloaded file is not a valid ZIP archive"
            echo "File info:"
            file "./downloaded-app/app_bundle.zip"
            echo "File contents (first 100 bytes as hex):"
            xxd -l 100 "./downloaded-app/app_bundle.zip" || hexdump -C "./downloaded-app/app_bundle.zip" | head -10
            
            # Check for common Azure blob storage errors
            if grep -q "PublicAccessNotPermitted" "./downloaded-app/app_bundle.zip" 2>/dev/null; then
              echo ""
              echo "üîç DIAGNOSIS: Azure blob storage access denied"
              echo "The URL appears to be an Azure blob storage link that requires authentication."
              echo "Possible issues:"
              echo "  1. SAS token has expired"
              echo "  2. URL is not publicly accessible"
              echo "  3. URL requires different authentication"
              echo ""
              echo "üí° SOLUTION: Please check that:"
              echo "  - The blob storage URL is publicly accessible, OR"
              echo "  - The SAS token in the URL is still valid, OR" 
              echo "  - Use a different download method that supports authentication"
            elif grep -q "<Error>" "./downloaded-app/app_bundle.zip" 2>/dev/null; then
              echo ""
              echo "üîç DIAGNOSIS: Server returned an error response instead of the file"
              echo "The server responded with an XML error message instead of the ZIP file."
              echo "Please check the URL and ensure it points directly to the downloadable file."
            fi
            
            exit 1
          else
            echo "‚úÖ ZIP file validation successful"
          fi

      - name: Verify download method
        run: |
          if [ -z "${{ inputs.artifact_name }}" ] && [ -z "${{ inputs.download_url }}" ]; then
            echo "‚ùå ERROR: Either artifact_name or download_url must be provided"
            exit 1
          fi
          
          if [ -n "${{ inputs.artifact_name }}" ] && [ -n "${{ inputs.download_url }}" ]; then
            echo "‚ö†Ô∏è WARNING: Both artifact_name and download_url provided, using artifact_name"
          fi

      - name: Unzip app bundle
        run: |
          echo "üì¶ Extracting app bundle..."
          
          # Find and extract the zip file
          if [ -f "./downloaded-app/app_bundle.zip" ]; then
            # Show ZIP contents first
            echo "üìã ZIP file contents:"
            unzip -l "./downloaded-app/app_bundle.zip" || {
              echo "‚ùå ERROR: Cannot list ZIP contents"
              echo "File info:"
              file "./downloaded-app/app_bundle.zip"
              exit 1
            }
            
            # Extract the ZIP file
            unzip "./downloaded-app/app_bundle.zip" -d ./downloaded-app/ || {
              echo "‚ùå ERROR: Failed to extract ZIP file"
              echo "ZIP test result:"
              unzip -t "./downloaded-app/app_bundle.zip"
              exit 1
            }
            echo "‚úÖ App bundle extracted successfully"
          else
            echo "‚ùå ERROR: app_bundle.zip not found in ./downloaded-app"
            echo "Contents of ./downloaded-app:"
            ls -la ./downloaded-app/
            exit 1
          fi

      - name: Verify app bundle
        id: verify-app
        run: |
          echo "üîç Verifying .app bundle..."

          APP_PATH=$(find ./downloaded-app -name "*.app" -type d -maxdepth 2 | head -n 1)
          
          echo "Contents of ./downloaded-app:"
          ls -la ./downloaded-app/

          if [ -z "$APP_PATH" ]; then
            echo "‚ùå ERROR: .app bundle not found"
            echo "Searching for .app files:"
            find ./downloaded-app -name "*.app" -type d
            exit 1
          fi

          if [ ! -f "$APP_PATH/Info.plist" ]; then
            echo "‚ùå ERROR: Invalid .app bundle - missing Info.plist"
            exit 1
          fi

          # Extract bundle ID for verification
          BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$APP_PATH/Info.plist")
          echo "üì± Found valid app bundle: $(basename "$APP_PATH")"
          echo "üìã Bundle ID: $BUNDLE_ID"
          
          echo "APP_PATH=$APP_PATH" >> $GITHUB_ENV
          echo "VERIFIED_BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV

      - name: List available iOS simulators
        run: |
          echo "üì± Available iOS Simulators:"
          xcrun simctl list devices available

      - name: Find and boot iOS Simulator
        id: boot-simulator
        run: |
          set -e
          DEVICE_NAME="${{ env.DEVICE_NAME }}"
          PLATFORM_VERSION="${{ env.PLATFORM_VERSION }}"
          
          echo "üîç Looking for: $DEVICE_NAME with iOS $PLATFORM_VERSION"
          
          # Use Python with JSON output for reliable parsing
          UDID=$(xcrun simctl list devices available -j | python3 -c "
            import json
            import sys

            data = json.load(sys.stdin)
            target_device = '$DEVICE_NAME'
            target_version = '$PLATFORM_VERSION'

            # Format the version for comparison (e.g., '26.0' -> 'iOS-26-0')
            formatted_version = 'iOS-' + target_version.replace(' ', '-').replace('.', '-')

            for runtime_key, devices in data.get('devices', {}).items():
                # Extract and format the runtime version from the key
                # Runtime keys look like: 'com.apple.CoreSimulator.SimRuntime.iOS-26-0'
                if formatted_version in runtime_key:
                    for device in devices:
                        if device.get('name') == target_device and device.get('isAvailable', False):
                            print(device['udid'])
                            sys.exit(0)

            # If we get here, device wasn't found
            sys.exit(1)
            " 2>/dev/null)
                
          if [ -z "$UDID" ]; then
            echo "‚ùå ERROR: Could not find $DEVICE_NAME with iOS $PLATFORM_VERSION"
            echo ""
            echo "Available simulators:"
            xcrun simctl list devices available
            echo ""
            echo "Debugging - Runtime keys:"
            xcrun simctl list devices available -j | python3 -c "
              import json
              import sys
              data = json.load(sys.stdin)
              for key in data.get('devices', {}).keys():
                  print(key)
            "
            exit 1
          fi
          
          echo "DEVICE_UDID=$UDID" >> $GITHUB_ENV
          echo "device_udid=$UDID" >> $GITHUB_OUTPUT
          echo "‚úÖ Found simulator: $DEVICE_NAME ($UDID)"
          
          # Boot the simulator with timeout protection
          echo "üöÄ Booting simulator..."
          xcrun simctl boot $UDID 2>/dev/null || echo "Simulator already booted or boot command completed"
          
          # Wait for boot to complete with timeout and fallback strategy
          echo "‚è≥ Waiting for simulator to boot (timeout: 180 seconds)..."
          
          BOOT_TIMEOUT=180
          BOOT_SUCCESS=false
          
          for i in $(seq 1 $BOOT_TIMEOUT); do
            # Check if simulator is booted
            SIMULATOR_STATUS=$(xcrun simctl list devices | grep "$UDID" | head -1)
            if echo "$SIMULATOR_STATUS" | grep -q "(Booted)"; then
              BOOT_SUCCESS=true
              echo "‚úÖ Simulator booted successfully after ${i} seconds"
              break
            fi
            
            # Progress indicator every 10 seconds
            if [ $((i % 10)) -eq 0 ]; then
              echo "‚è≥ Still waiting... (${i}/${BOOT_TIMEOUT} seconds)"
              echo "Current status: $SIMULATOR_STATUS"
            fi
            
            sleep 1
          done
          
          if [ "$BOOT_SUCCESS" = false ]; then
            echo "‚ùå ERROR: Simulator failed to boot within $BOOT_TIMEOUT seconds"
            echo "Final status: $(xcrun simctl list devices | grep "$UDID" | head -1)"
            echo ""
            echo "üîß Attempting recovery..."
            
            # Try to shutdown and reboot once
            echo "üîÑ Shutting down simulator..."
            xcrun simctl shutdown $UDID || true
            sleep 5
            
            echo "üöÄ Attempting second boot..."
            xcrun simctl boot $UDID
            
            # Give it one more chance with shorter timeout
            echo "‚è≥ Final boot attempt (60 seconds timeout)..."
            FINAL_TIMEOUT=60
            FINAL_SUCCESS=false
            
            for i in $(seq 1 $FINAL_TIMEOUT); do
              SIMULATOR_STATUS=$(xcrun simctl list devices | grep "$UDID" | head -1)
              if echo "$SIMULATOR_STATUS" | grep -q "(Booted)"; then
                FINAL_SUCCESS=true
                echo "‚úÖ Simulator recovered and booted after ${i} seconds"
                break
              fi
              sleep 1
            done
            
            if [ "$FINAL_SUCCESS" = false ]; then
              echo "‚ùå FATAL: Simulator boot failed completely"
              echo "This might be a CI environment issue with iOS simulators"
              exit 1
            fi
          fi
          
          # Double-check simulator status and ensure it's ready for testing
          echo "üîç Final verification that simulator is ready..."
          SIMULATOR_STATUS=$(xcrun simctl list devices | grep "$UDID" | head -1)
          echo "Simulator status: $SIMULATOR_STATUS"
          
          if echo "$SIMULATOR_STATUS" | grep -q "(Booted)"; then
            echo "‚úÖ Simulator is booted and ready for testing"
          else
            echo "‚ùå ERROR: Simulator failed to reach booted state"
            echo "Current status: $SIMULATOR_STATUS"
            exit 1
          fi

      - name: Install app on simulator
        id: install-app
        run: |
          echo "üì≤ Installing app on simulator..."
          echo "Device UDID: ${{ env.DEVICE_UDID }}"
          echo "App path: ${{ env.APP_PATH }}"
          
          # Install the app
          xcrun simctl install "${{ env.DEVICE_UDID }}" "${{ env.APP_PATH }}"
          
          # Extract and output bundle ID
          BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "${{ env.APP_PATH }}/Info.plist")
          echo "BUNDLE_ID=${BUNDLE_ID}" >> $GITHUB_ENV
          echo "bundle_id=${BUNDLE_ID}" >> $GITHUB_OUTPUT
          
          echo "‚úÖ App installed successfully"
          echo "üìã Bundle ID: ${BUNDLE_ID}"

      - name: Launch and verify app
        run: |
          echo "üöÄ Launching app..."
          xcrun simctl launch "${{ env.DEVICE_UDID }}" "${{ env.BUNDLE_ID }}"
          
          echo "‚è≥ Waiting for app to initialize..."
          sleep 5
          
          # Verify app is installed and accessible for testing
          echo "üîç Final app verification before testing..."
          if xcrun simctl listapps "${{ env.DEVICE_UDID }}" | grep -q "${{ env.BUNDLE_ID }}"; then
            echo "‚úÖ App ${{ env.BUNDLE_ID }} is installed and available for Appium testing"
          else
            echo "‚ùå ERROR: App not found after installation"
            echo "Installed apps:"
            xcrun simctl listapps "${{ env.DEVICE_UDID }}"
            exit 1
          fi
          
          echo "üéØ App launched successfully and ready for testing"

      - name: Installation Summary
        run: |
          echo "## iOS App Installation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Device:** ${{ env.DEVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**iOS Version:** ${{ env.PLATFORM_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Simulator UDID:** ${{ env.DEVICE_UDID }}" >> $GITHUB_STEP_SUMMARY
          echo "**Bundle ID:** ${{ env.BUNDLE_ID }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Status:** Ready for testing" >> $GITHUB_STEP_SUMMARY